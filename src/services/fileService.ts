import { Conversation, Reflection } from '../types';

export interface ConversationExport {
  conversation: Conversation;
  reflection?: Reflection;
  exportDate: string;
}

export class FileService {
  public exportConversationAsText(conversation: Conversation, reflection?: Reflection): string {
    const date = new Date(conversation.timestamp).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });

    const toneLabel = this.getToneLabel(conversation.parentTone);

    let content = `SUPPORTIVE VOICE CONVERSATION
Date: ${date}
Tone: ${toneLabel}

═══════════════════════════════════════

WHAT I SHARED:
${conversation.userMessage}

═══════════════════════════════════════

MY SUPPORTIVE VOICE'S RESPONSE:
${conversation.parentResponse}

═══════════════════════════════════════`;

    if (reflection) {
      const reflectionDate = new Date(reflection.timestamp).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

      content += `

REFLECTION (${reflectionDate}):

Wellness Rating: ${'★'.repeat(reflection.healingRating)}${'☆'.repeat(5 - reflection.healingRating)} (${reflection.healingRating}/5)

${reflection.emotionalState ? `How I Felt: ${reflection.emotionalState}` : ''}

${reflection.insights ? `Insights & Thoughts:\n${reflection.insights}` : ''}

═══════════════════════════════════════`;
    }

    content += `

This conversation is part of my personal development journey with supportive voice guidance.
Generated by Personal Development Assistant - ${new Date().getFullYear()}`;

    return content;
  }

  public downloadConversation(conversation: Conversation, reflection?: Reflection): void {
    const content = this.exportConversationAsText(conversation, reflection);
    const date = new Date(conversation.timestamp).toISOString().split('T')[0];
    const filename = `supportive-conversation-${date}.txt`;

    this.downloadTextFile(content, filename);
  }

  public exportAllConversations(conversations: Conversation[], reflections: Reflection[]): string {
    const exportDate = new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    let content = `MY PERSONAL DEVELOPMENT JOURNEY
Export Date: ${exportDate}
Total Conversations: ${conversations.length}
Total Reflections: ${reflections.length}

═══════════════════════════════════════════════════════════════

`;

    // Sort conversations by date (newest first)
    const sortedConversations = [...conversations].sort(
      (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );

    sortedConversations.forEach((conversation, index) => {
      const reflection = reflections.find(r => r.conversationId === conversation.id);
      
      content += `CONVERSATION ${index + 1}\n`;
      content += this.exportConversationAsText(conversation, reflection);
      content += '\n\n═══════════════════════════════════════════════════════════════\n\n';
    });

    // Add summary statistics
    if (reflections.length > 0) {
      const avgWellness = reflections.reduce((sum, r) => sum + r.healingRating, 0) / reflections.length;
      const maxWellness = Math.max(...reflections.map(r => r.healingRating));
      const minWellness = Math.min(...reflections.map(r => r.healingRating));

      content += `PERSONAL DEVELOPMENT SUMMARY:

Average Wellness Rating: ${avgWellness.toFixed(1)}/5 (${'★'.repeat(Math.round(avgWellness))}${'☆'.repeat(5 - Math.round(avgWellness))})
Highest Wellness Rating: ${maxWellness}/5
Lowest Wellness Rating: ${minWellness}/5

Most Common Emotional States:
${this.getMostCommonEmotions(reflections)}

═══════════════════════════════════════════════════════════════

`;
    }

    content += `This export contains my complete personal development journey with supportive voice guidance.
Generated by Personal Development Assistant - ${new Date().getFullYear()}`;

    return content;
  }

  public downloadAllConversations(conversations: Conversation[], reflections: Reflection[]): void {
    const content = this.exportAllConversations(conversations, reflections);
    const date = new Date().toISOString().split('T')[0];
    const filename = `my-personal-development-journey-${date}.txt`;

    this.downloadTextFile(content, filename);
  }

  private downloadTextFile(content: string, filename: string): void {
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }

  private getToneLabel(tone: string): string {
    const labels = {
      nurturing: 'Nurturing & Comforting',
      validating: 'Validating & Understanding',
      protective: 'Protective & Reassuring',
      encouraging: 'Encouraging & Empowering'
    };
    return labels[tone as keyof typeof labels] || 'Nurturing & Comforting';
  }

  private getMostCommonEmotions(reflections: Reflection[]): string {
    const emotions = reflections
      .map(r => r.emotionalState)
      .filter(Boolean)
      .reduce((acc, emotion) => {
        acc[emotion] = (acc[emotion] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

    return Object.entries(emotions)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([emotion, count]) => `• ${emotion} (${count} times)`)
      .join('\n') || 'No emotional states recorded';
  }
}

export const fileService = new FileService();